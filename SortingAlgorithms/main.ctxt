#BlueJ class context
comment0.params=args
comment0.target=void\ main(java.lang.String[])
comment1.params=args
comment1.target=void\ mainNLGN(java.lang.String[])
comment10.params=arr\ i
comment10.target=void\ maxheap(int[],\ int)
comment10.text=Function\ to\ swap\ largest\ element\ in\ heap
comment11.params=arr\ i\ j
comment11.target=void\ swap(int[],\ int,\ int)
comment11.text=Function\ to\ swap\ two\ numbers\ in\ an\ array
comment12.params=args
comment12.target=void\ mainheap(java.lang.String[])
comment12.text=Main\ method
comment13.params=intArray
comment13.target=void\ qsm3(int[])
comment14.params=intArray\ left\ right
comment14.target=void\ recQuickSort(int[],\ int,\ int)
comment15.params=intArray\ left\ right
comment15.target=int\ medianOf3(int[],\ int,\ int)
comment16.params=intArray\ left\ right\ pivot
comment16.target=int\ partitionIt(int[],\ int,\ int,\ double)
comment17.params=intArray\ left\ right
comment17.target=void\ manualSort(int[],\ int,\ int)
comment2.params=x
comment2.target=void\ bubble_sort(int[])
comment2.text=\n\ Bubble\ Sort\n\ Runs\ in\ O(n^2)\ time.\ \n\ Compares\ pairs\ of\ numbers\ over\ the\ whole\ array\ and\ swaps\ when\ \n\ the\ 1st\ number\ is\ bigger\ than\ the\ 2nd.\ \n
comment3.params=x
comment3.target=void\ selection_sort(int[])
comment3.text=\n\ Selection\ Sort\ -\ O(n^2)\ \n\ \n\ This\ sort\ finds\ the\ min\ value\ in\ the\ list,\ \n\ and\ swaps\ it\ with\ the\ index\ i\ as\ you're\ going\ \n\ through\ the\ array.\ \n
comment4.params=arr
comment4.target=void\ insertion_sort(int[])
comment4.text=\n\ Non-recursive\ Insertion\ Sort\ \n\ You\ have\ a\ cur\ index\ (i)\ and\ a\ j\ index\ that\ is\ paired\n\ with\ j-1\ for\ swapping\ numbers\ all\ around\ the\ list.\ \n\ \n\ The\ outer\ for\ loop\ keeps\ track\ of\ where\ you\ are\ in\ the\ list.\ \n\ \n\ The\ inner\ while\ loop\ initially\ looks\ at\ the\ cur\ value\n\ (i\ or\ initially\ j)\ and\ the\ value\ right\ before\ it(j-1),\ \n\ and\ if\ the\ value\ of\ arr[j-1]\ is\ >\ arr[j]\ then\ you\ SWAP.\ \n\ the\ while\ loop\ continues\ backwards\ swapping\ all\ values\ \n\ until\ 0\ -\ i\ is\ sorted.\ then\ i\ is\ incremented\ and\ the\ process\n\ is\ repeated.\ \n
comment5.params=arr\ low\ high
comment5.target=void\ quick_sort(int[],\ int,\ int)
comment5.text=\n\ Quick\ Sort\ O(nlgn)\ in\ most\ cases\:\ \n\ Find\ a\ pivot\ value\ (in\ this\ case\ the\ middle\ value)\ \n\ and\ split\ the\ array.\ Iterate\ through\ the\ array\ from\ bottom\ and\ \n\ from\ the\ top\ with\ two\ counters.\ i\ from\ bottom\ and\ j\ from\ top.\ \n\ when\ i\ finds\ a\ value\ that\ is\ >\ than\ the\ pivot,\ swap\ it\ when\ j\ \n\ finds\ a\ value\ that\ is\ less\ than\ the\ pivot.\ \n\ \n\ You\ now\ have\ 2\ somewhat\ sorted\ lists,\ so\ now\ recursively\ \n\ call\ quick\ sort\ on\ each\ list.\ \n
comment6.params=inputArray
comment6.target=void\ merge_sort(int[])
comment6.text=\n\ Merge\ Sort\ O(nlgn)\ \n\ \ Continuously\ divide\ list\ in\ half\ until\ you\ are\ \n\ \ looking\ at\ single\ integers,\ repopulate\ the\ list\ in\ order\ \n\ \ by\ comparing\ each\ list\ with\ 2\ counters.\ \n
comment7.params=left\ right\ arr
comment7.target=void\ merge(int[],\ int[],\ int[])
comment8.params=arr
comment8.target=void\ heap_sort(int[])
comment8.text=Sort\ Function
comment9.params=arr
comment9.target=void\ heapify(int[])
comment9.text=Function\ to\ build\ a\ heap
numComments=18
