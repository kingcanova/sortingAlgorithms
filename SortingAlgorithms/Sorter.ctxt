#BlueJ class context
comment0.params=x
comment0.target=void\ bubble_sort(int[])
comment0.text=\r\n\ Bubble\ Sort\r\n\ Runs\ in\ O(n^2)\ time.\ \r\n\ Compares\ pairs\ of\ numbers\ over\ the\ whole\ array\ and\ swaps\ when\ \r\n\ the\ 1st\ number\ is\ bigger\ than\ the\ 2nd.\ \r\n
comment1.params=x
comment1.target=void\ selection_sort(int[])
comment1.text=\r\n\ Selection\ Sort\ -\ O(n^2)\ \r\n\ \r\n\ This\ sort\ finds\ the\ min\ value\ in\ the\ list,\ \r\n\ and\ swaps\ it\ with\ the\ index\ i\ as\ you're\ going\ \r\n\ through\ the\ array.\ \r\n
comment10.params=args
comment10.target=void\ main(java.lang.String[])
comment11.params=arr\ arrType\ sortingMethod
comment11.target=void\ runTimeSave(int[],\ java.lang.String,\ java.lang.String)
comment12.params=fileName\ size\ time
comment12.target=void\ writeData(java.lang.String,\ int,\ long)
comment2.params=arr
comment2.target=void\ insertion_sort(int[])
comment2.text=\r\n\ Non-recursive\ Insertion\ Sort\ \r\n\ You\ have\ a\ cur\ index\ (i)\ and\ a\ j\ index\ that\ is\ paired\r\n\ with\ j-1\ for\ swapping\ numbers\ all\ around\ the\ list.\ \r\n\ \r\n\ The\ outer\ for\ loop\ keeps\ track\ of\ where\ you\ are\ in\ the\ list.\ \r\n\ \r\n\ The\ inner\ while\ loop\ initially\ looks\ at\ the\ cur\ value\r\n\ (i\ or\ initially\ j)\ and\ the\ value\ right\ before\ it(j-1),\ \r\n\ and\ if\ the\ value\ of\ arr[j-1]\ is\ >\ arr[j]\ then\ you\ SWAP.\ \r\n\ the\ while\ loop\ continues\ backwards\ swapping\ all\ values\ \r\n\ until\ 0\ -\ i\ is\ sorted.\ then\ i\ is\ incremented\ and\ the\ process\r\n\ is\ repeated.\ \r\n
comment3.params=inputArray
comment3.target=void\ merge_sort(int[])
comment3.text=\r\n\ Merge\ Sort\ O(nlgn)\ \r\n\ \ Continuously\ divide\ list\ in\ half\ until\ you\ are\ \r\n\ \ looking\ at\ single\ integers,\ repopulate\ the\ list\ in\ order\ \r\n\ \ by\ comparing\ each\ list\ with\ 2\ counters.\ \r\n
comment4.params=left\ right\ arr
comment4.target=void\ merge(int[],\ int[],\ int[])
comment5.params=arr\ low\ high
comment5.target=void\ quick_sort(int[],\ int,\ int)
comment5.text=\r\n\ Quick\ Sort\ O(nlgn)\ in\ most\ cases\:\ \r\n\ Find\ a\ pivot\ value\ (in\ this\ case\ the\ middle\ value)\ \r\n\ and\ split\ the\ array.\ Iterate\ through\ the\ array\ from\ bottom\ and\ \r\n\ from\ the\ top\ with\ two\ counters.\ i\ from\ bottom\ and\ j\ from\ top.\ \r\n\ when\ i\ finds\ a\ value\ that\ is\ >\ than\ the\ pivot,\ swap\ it\ when\ j\ \r\n\ finds\ a\ value\ that\ is\ less\ than\ the\ pivot.\ \r\n\ \r\n\ You\ now\ have\ 2\ somewhat\ sorted\ lists,\ so\ now\ recursively\ \r\n\ call\ quick\ sort\ on\ each\ list.\ \r\n
comment6.params=n\ s\ e
comment6.target=int[]\ n_range(int,\ int,\ int)
comment7.params=n
comment7.target=int[]\ n_ascending(int)
comment8.params=n
comment8.target=int[]\ n_decending(int)
comment9.params=n\ swaps
comment9.target=int[]\ n_nearly(int,\ int)
numComments=13
